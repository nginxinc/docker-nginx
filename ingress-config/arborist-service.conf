#
# workspace AuthZ-proxy uses arborist to provide authorization to workpace services
# that don't implement our authn or authz i.e. shiny, jupyter.
#
location = /gen3-authz {
    internal;
    error_page 400 =403 @errorworkspace;
    error_page 500 =403 @errorworkspace;

    # avoid setting $upstream in authz subrequests ...
    set $upstream_authz http://${arborist_release_name}-service.$namespace.svc.cluster.local;

    proxy_pass $upstream_authz/auth/proxy?resource=$authz_resource&method=$authz_method&service=$authz_service;

    proxy_pass_request_body off;
    proxy_set_header Authorization "$access_token";
    proxy_set_header Content-Length "";
    proxy_set_header X-Forwarded-For "$realip";
    proxy_set_header X-UserId "$userid";
    proxy_set_header X-ReqId "$request_id";
    proxy_set_header X-SessionId "$session_id";
    proxy_set_header X-VisitorId "$visitor_id";
    proxy_set_header X-Original-URI $request_uri;
    proxy_intercept_errors on;

    # nginx bug that it checks even if request_body off
    client_max_body_size 0;
}

#
# authorization endpoint
# https://hostname/authz?resource=programs/blah&method=acb&service=xyz
#
location ~ /authz/? {
    if ($csrf_check !~ ^ok-\S.+$) {
        return 403 "failed csrf check";
    }
    set $proxy_service  "arborist";
    set $upstream http://${arborist_release_name}-service.$namespace.svc.cluster.local;

    proxy_pass $upstream/auth/proxy?resource=$arg_resource&method=$arg_method&service=$arg_service;
}

location = /authz/resources {
    if ($csrf_check !~ ^ok-\S.+$) {
        return 403 "failed csrf check";
    }
    set $proxy_service  "arborist";
    set $upstream http://${arborist_release_name}-service.$namespace.svc.cluster.local;

    proxy_pass $upstream/auth/resources;
}

location = /authz/mapping {
    if ($csrf_check !~ ^ok-\S.+$) {
        return 403 "failed csrf check";
    }

    # Do not expose POST /auth/mapping
    limit_except GET {
        deny all;
    }

    set $proxy_service  "arborist";
    set $upstream http://${arborist_release_name}-service.$namespace.svc.cluster.local;

    # Do not pass the username arg here! Otherwise anyone can see anyone's access.
    # Arborist will fall back to parsing the jwt for username.
    proxy_pass $upstream/auth/mapping;
}

#
# Little endpoint for testing that authz is being enforced
#
location = /gen3-authz-test {
    set $authz_resource "/fail";
    set $authz_method "user";
    set $authz_service "bogus";

    # be careful - sub-request runs in same context as this request
    auth_request /gen3-authz;

    set $proxy_service  "${fence_release_name}";
    set $upstream http://${fence_release_name}-service.$namespace.svc.cluster.local;
    proxy_pass $upstream/$authz_method;
}
